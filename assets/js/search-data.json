{
  
    
        "post0": {
            "title": "A "zero-dimensional" energy balance model of Earth's climate",
            "content": "import xarray as xr import numpy as np import matplotlib.pyplot as plt . 1) Background: climate physics . The simplest climate model can be conceptualized as: . begin{align} text{change in heat content} = &amp; + text{absorbed solar radiation (energy from the Sun&#39;s rays)} newline &amp; - text{outgoing thermal radiation (i.e. blackbody cooling to space)} newline &amp; + text{human-caused greenhouse effect (trapped outgoing radiation)} end{align}where each of these is interpreted as an average over the entire globe (hence &quot;zero-dimensional&quot;). . . To make this simple conceptual model quantitative, we need a mathematical formulation for each of these four processes. . 1.1 Absorbed solar radiation . At Earth&#39;s orbital distance from the Sun, the power of the Sun&#39;s rays that intercept the Earth is equal to . S = 1368 # solar insolation [W/m^2] (energy per unit time per unit area) . A small fraction . alpha = 0.3 # albedo, or planetary reflectivity [unitless] . of this incoming solar radiation is reflected back out to space (by reflective surfaces like white clouds, snow, and ice), with the remaining fraction $(1- alpha)$ being absorbed. Since the incoming solar rays are all approximately parallel this far from the Sun, the cross-sectional area of the Earth that intercepts them is just a disc of area $ pi R^{2}$. Since all of the other terms we will consider act on the entire surface area $4 pi R^{2}$ of the spherical Earth, the absorbed solar radiation per unit surface area (averaged over the entire globe) is reduced by a factor of 4. . . The absorbed solar radiation per unit area is thus . $ text{absorbed solar radiation} equiv frac{S(1- alpha)}{4}$ . def absorbed_solar_radiation(S, alpha): return (S*(1-alpha)/4) # [W/m^2] . 1.2) Outgoing thermal radiation . The outgoing thermal radiation term (or &quot;blackbody cooling to space&quot;) represents the combined effects of negative feedbacks that dampen warming, such as blackbody radiation, and positive feedbacks that amplify warming, such as the water vapor feedback. . Since these physics are too complicated to deal with here, we linearize the model by considering only the first term of a Taylor Series expansion . $$ G(T) sim G(T_0) + G^{&#39;}(T_0) (T-T_0) = G^{&#39;}(T_0)T + (G(T_0)-G^{&#39;}(T_0)T_0) $$ . around the pre-industrial equilibrium temperature . T0 = 14. # preindustrial temperature [°C] . To simplify the expression, we define: . $ A equiv G^{&#39;}(T_0)T_0 $ . $ B equiv - G^{&#39;}(T_0) text{ (the climate feedback parameter),}$ . which gives . $$ text{outgoing thermal radiation} equiv G(T) sim A - BT$$ . def outgoing_thermal_radiation(T, A, B): return A - B*T . The value of the climate feedback parameter used here, . B = -1.3 # climate feedback parameter [W/m^2/°C], . comes from a bottom-up estimate based on the best understanding of the various climate feedbacks (read more here). . Note: Since $B&lt;0$ , this tells us that the overall climate feedback is negative (i.e. stabilizing). Positivefeedbacks cause to become less negative, reducing the efficiency with which Earth cools itself by radiating thermal energy to space, and thus amplifying warming. . The value $A$ of is given by the definition of a preindustrial equilibrium, i.e. the fact that before human influence, Earth&#39;s energy budget was perfectly balanced: . absorbed solar radiation = outgoing thermal radiation . or . $ frac{S (1- alpha)}{4} equiv A - BT_0$ . By rearanging this equation, we find that the value of $A$ is given by . A = S*(1. - alpha)/4 + B*T0 # [W/m^2]. . Human-caused greenhouse effect . Empirically, the greenhouse effect is known to be a logarithmic function of gaseous carbon dioxide (CO$_2$) concentrations . $$ text{Human-caused greenhouse effect} = a * ln frac{CO_2}{CO{_2}_{PI}} $$ . where . a = 5 # CO2 forcing coefficient [W/m^2] . CO2_PI = 280 # preindustrial CO2 concentration [parts per million; ppm]; . def greenhouse_effect(CO2, a=5, CO2_PI = 280): return a*np.log(CO2/CO2_PI) . co2_present = 420 co2_range = 280*2**np.linspace(-1,3,100) plt.plot(co2_range, greenhouse_effect(co2_range), color = &quot;black&quot;) plt.ylabel(&#39;Radiative forcing [$W/m^2$]&#39;) plt.xlabel(&#39;$CO_2$ concentration [ppm]&#39;) plt.plot(CO2_PI, greenhouse_effect(CO2_PI), marker=&quot;.&quot;, markersize = 20, label = &quot;pre-industrial (PI)&quot;, color = &quot;blue&quot;) plt.plot(co2_present, greenhouse_effect(co2_present), marker=&quot;.&quot;, markersize = 20, label = &quot;present day (2020)&quot;, color = &quot;red&quot;) plt.xticks([280, 280*2, 280*4, 280*8]) plt.legend(loc = 4) plt.grid() . 1.4) Change in heat content . The heat content $CT$ is determined by the temperature $T$ (in Kelvin) and the heat capacity of the climate system. While we are interested in the temperature of the atmosphere, which has a very small heat capacity, its heat is closely coupled with that of the upper ocean, which has a much larger heat capacity of . C = 51 . The change in heat content over time is thus simply given by $ frac{d(CT)}{dt}$. Since the heat capacity of sea water hardly changes with temperature, we can rewrite this in terms of the change in temperature with time as: . $$ text{change in heat content} = C frac{dT}{dt} $$ . 1.5) &quot;zero-dimensional&quot; climate model equation . Combining all of these subcomponent models, we write the governing equation of the &quot;zero-dimensional&quot; energy balance climate model as the Ordinary Differential Equation (ODE) . $$ C frac{dT}{dt} = frac{S (1- alpha)}{4} - ( A - BT_0) + a * ln frac{CO_2}{CO{_2}_{PI}} $$ . which determines the time evolution of Earth&#39;s globally-averaged surface temperature. . 2) Numerical solution method and data structures . 2.1) Discretization . The energy balance model equation above can be discretized in time as . $$ C frac{T(t+ Delta t) - T(t)}{ Delta t} = frac{S (1- alpha)}{4} - ( A - BT_0) + a * ln frac{CO_2}{CO{_2}_{PI}} $$ . Our finite difference equation, which results from a first-order truncation of the Taylor series expansion, approximates the exact ordinary differential equation above in the limit that $ Delta t rightarrow 0$. In practice, we can keep decreasing $ Delta t$ until the solution converges within a tolerable error. . Hereafter, we use the subscript $n$ to denote the $n$-th timestep, where $T_{n+1} equiv T(t_{n+1})$ denotes the temperature at the next timestep $t_{n+1} = t_n + Delta t$. . By re-arranging the equation, we can solve for the temperature at the next timestep $n+1$ based on the known temperature at the present timestep $n$: . $$ T_{n+1} = T_n + frac{ Delta t}{C} bigg[ frac{S (1- alpha)}{4} - ( A - BT_n) + a * ln frac{CO_2}{CO{_2}_{PI}} bigg] $$ . 2.2) Timestepping . More generally, we recognize this equation to be of the form: . $$ T_{n+1} = T_n + Delta t cdot text{tendency}(T_n; ...),$$ . which we implement below (don&#39;t forget to update the time as well, $t_{n+1} = t_n + Delta t$), which takes in an instance of our anticipated energy balance model EBM type as its only argument. . class ebm(): &quot;&quot;&quot; Zero order energy balance model &quot;&quot;&quot; def __init__(self, T, t, deltat, CO2): self.T = np.array(T) self.t = t self.deltat = deltat self.C = C self.a = a self.A = A self.B = B self.co2_pi = CO2_PI self.alpha = alpha self.S = S self.co2 = CO2 def tendency(self): if self.T.size == 1: return 1. / self.C * ( + absorbed_solar_radiation(alpha = self.alpha, S=self.S) - outgoing_thermal_radiation(self.T, A = self.A, B=self.B) + greenhouse_effect(self.co2(self.t), a = self.a, CO2_PI=self.co2_pi) ) else: return 1. / self.C * ( + absorbed_solar_radiation(alpha = self.alpha, S=self.S) - outgoing_thermal_radiation(self.T[-1], A = self.A, B=self.B) + greenhouse_effect(self.co2(self.t[-1]), a = self.a, CO2_PI=self.co2_pi) ) @property def timestep(self): if self.T.size == 1: self.T = np.append(self.T, self.T + self.deltat * self.tendency()) self.t = np.append(self.t, self.t + self.deltat) else: self.T = np.append(self.T, self.T[-1] + self.deltat * self.tendency()) self.t = np.append(self.t, self.t[-1] + self.deltat) . 2.4) Running simulations of the energy balance model . Let&#39;s define a function that runs an EBM simulation by timestepping forward until a given end_year. . def run_ebm(ebm, end_year): for year in range(end_year): ebm.timestep . For example, let us consider the case where CO₂ emissions increase by 1% year-over-year from the preindustrial value [CO$_2$] = $280.0$ ppm, starting at T=T₀=14°C in year t=0 and with a timestep Δt = 1 year. . def CO2_test(t): return CO2_PI ** (1 + 1/100)**t EBM = ebm(T0, t=0, deltat=1, CO2=CO2_test) . EBM.T . array(14.) . EBM.timestep . EBM.T . array([14. , 14. , 14.0055243]) . 3) Energy balance model applications . 3.1) Why was Earth&#39;s preindustrial climate so stable? . Let us consider the simple case where CO₂ concentrations remain at their pre-industrial temperatures. . def CO2_test(t): return 280 EBM = ebm(T0, 0, 1, CO2_test) . run_ebm(EBM, 200) . t0s = np.arange(12,16,0.2) for i in t0s: EBM = ebm(i, 0, 1, CO2_test) run_ebm(EBM, 200) plt.plot(EBM.T) plt.grid() plt.xlabel(&quot;year&quot;) plt.ylabel(&quot;temperature [°C]&quot;) . Text(0, 0.5, &#39;temperature [°C]&#39;) . This figure shows that, no matter where we start out, the overall negative feedbacks ($B&lt;0$) restore the temperature to the preindustrial equilibrum value of $T_0$ = 14.0 °C, over an exponential timescale of about 100 years. . 3.2) Historical global warming fueled by greenhouse gas emissions . Human greenhouse gas emissions have fundamentally altered Earth&#39;s energy balance, moving us away from the stable preindustrial climate of the past few thousand years. . Since human CO₂ emissions are the main driver of global warming, we expect that if we plug historical CO₂ increases into our model (&quot;forcing&quot; it), we should roughly reproduce the observed historical global warming. . The observed increase of CO2 concentrations can be fairly accurately modelled by the simple cubic formula below. . def co2_hist(t): return 280 * (1+ ((t-1850)/220)**3) . EBM = ebm(T0, 1850, 1, co2_hist) run_ebm(EBM, 170) . import pandas as pd url = &quot;https://data.giss.nasa.gov/gistemp/graphs/graph_data/Global_Mean_Estimates_based_on_Land_and_Ocean_Data/graph.txt&quot; temp = pd.read_csv(url, header = None, skiprows=5, index_col=0, delimiter=&quot; &quot;) temp = temp + 14.15 CO2_url = &quot;https://scrippsco2.ucsd.edu/assets/data/atmospheric/stations/in_situ_co2/monthly/monthly_in_situ_co2_mlo.csv&quot; co2_data = pd.read_csv(CO2_url, header = 46,skiprows=8, index_col=0) co2_data = co2_data.iloc[4:] co2_data = pd.to_numeric(co2_data.iloc[:,5]) co2_data[co2_data&lt;= 0] = np.nan co2_data.index = pd.to_datetime(co2_data.index) co2_data = co2_data.groupby(co2_data.index.year).mean() . &lt;ipython-input-27-ad0381c77880&gt;:3: ParserWarning: Falling back to the &#39;python&#39; engine because the &#39;c&#39; engine does not support regex separators (separators &gt; 1 char and different from &#39; s+&#39; are interpreted as regex); you can avoid this warning by specifying engine=&#39;python&#39;. temp = pd.read_csv(url, header = None, . f, (ax, bx) = plt.subplots(1,2, figsize=(8,4)) ax.plot(np.arange(1850, 2020), co2_hist(np.arange(1850, 2020)), label = &quot;EBM model&quot;) ax.plot(co2_data.index, co2_data.values, label=&quot;Keeling Curve&quot;) ax.set_ylabel(&quot;$CO_2$ concentration [ppm]&quot;) ax.grid() ax.set_xlabel(&quot;Year&quot;) ax.legend() bx.plot(np.arange(1850, 2021), EBM.T, label=&quot;EBM model&quot;) temp.plot(ax = bx) bx.set_ylabel(&quot;Temperature [°C]&quot;) bx.grid() bx.legend([&quot;EBM Model&quot;, &quot;NASA Observations&quot;, &quot;NASA Obs roll. mean&quot;]) bx.set_xlabel(&quot;Year&quot;) f.tight_layout() . CO&#8322; emissions predict the trend, but what about the climate noise? . CO$_2$ emissions predict the trend, but what about the climate noise? Our model does a good job of predicting the long-term trend of increasing temperatures, but what about all of the noise in the observations? These are real signals due to natural variability of the Earth system, not artifacts due to instrumental noise. . This natural noise arises due to the turbulent and chaotic fluid dynamics of the atmosphere and ocean, which we will explore further in Lecture 4 and are illustrated below. . Now that we&#39;ve convinced ourselves that the model accurately reproduces historical warming, we can use it to project how much warming we might expect due to future CO₂ emissions. . 3.3) Best- and worst-case projections of future global warming . Consider two divergent hypothetical futures: . 1) a low-emissions world in which emissions decrease such that CO2 concentrations stay below 500 ppm by 2100 (known in climate circles as &quot;RCP2.6&quot;) and . 2) a high-emissions world in which emissions continue increasing and CO2 concentrations soar upwards of 1200 ppm (&quot;RCP8.5&quot;). . def CO2_RCP26(t): return 280 * (1+ ((t-1850)/220)**3 * np.minimum(1., np.exp(-((t-1850)-170)/100))) def CO2_RCP85(t): return 280 * (1+ ((t-1850)/220)**3 * np.maximum(1., np.exp(((t-1850)-170)/100))) . In the low-emissions scenario, the temperature increase stays below $ Delta T$ = 2 °C by 2100, while in the high-emissions scenario temperatures soar upwards of 3.5ºC above pre-industrial levels. . EBM1 = ebm(T0, 1850, 1, CO2_RCP26) EBM2 = ebm(T0, 1850, 1, CO2_RCP85) run_ebm(EBM1, 249) run_ebm(EBM2, 249) . f, (ax, bx) = plt.subplots(1,2, figsize = (8,4)) ax.plot(np.arange(1850, 2100), CO2_RCP26(np.arange(1850,2100)), color = &quot;Blue&quot;, label = &quot;RCP 2.6 low emissions&quot;) ax.plot(np.arange(1850, 2100), CO2_RCP85(np.arange(1850,2100)), color = &quot;Red&quot;, label = &quot;RCP 8.5 High emissions&quot;) ax.plot(2020, CO2_RCP26(2020), marker=&quot;.&quot;, markersize = 20, label = &quot;we are here&quot;, color = &quot;black&quot;) ax.set_ylabel(&quot;$CO_2$ concentration [ppm]&quot;) ax.legend() bx.plot(np.arange(1850, 2100), EBM1.T, color = &quot;Blue&quot;) bx.plot(np.arange(1850, 2100), EBM2.T, color = &quot;Red&quot;) bx.axhline(y = 16, label = &quot;Paris Agreement n threshold (2°C warming)&quot;, ls=&quot;--&quot;, color = &quot;black&quot;) bx.set_ylabel(&quot;Temperature [°C]&quot;) bx.plot(2020, EBM1.T[170], marker=&quot;.&quot;, markersize = 20, label = &quot;we are here&quot;, color = &quot;black&quot;) bx.legend() f.tight_layout() .",
            "url": "https://florianboergel.github.io/personal_blog/jupyter/2020/11/11/energy-model.html",
            "relUrl": "/jupyter/2020/11/11/energy-model.html",
            "date": " • Nov 11, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Red noise",
            "content": "Hasselmann (as explained by Dommenget and Latif, 2000) . Hasselmann (1976) attempts to explain the mechanism of natural climate variabilty by dividing the climate system into a fast system and a slow system. The fast system could be the atmosphere, represented as white noise. The slower component is the ocean and is explained by the integration of white noise (AR-1). In this picture the ocean is merely a passive part of the climate system, which amplifies long-term variability, due to its large heat capacity, but dynamical processes in the ocean are not considered. . The resulting stochastic model of the SST variability is described by an autoregressive process of the first order, which is the simplest statistical model that can be applied to a stationary process. The stochastic climate model by Hasselmann is tehrefore often chosen as the null hypothesis of SST variability. . Slab ocean-atmosphere models can be regarded as a numerical realization of the null hypothesis (AR(1)-process) of Hasselmann&#39;s stochastic climate model. . The null hypothesis of SST variability in the midlatitudes, described by Hasselmann&#39;s stochastic climate model, assumes that the SST variability is well described by the integration of the atmospheric heat flux with the heat capacity of the ocean&#39;s mixed layer. . $ frac{d SST}{dT} = frac{1}{C_p rho_w d_{mix}}* F + Delta T_c$ . $C_p$ = specifc heat of sea water . $ rho_w$ = density of sea water . $d_{mix}$ = depth of mixed layer . $F$ = net atmospheric heat flux . $ Delta T_c$ = climatology temperature correction . The only free parameter in this eqaution is the mixed layer depth, which was chosen to be 50 meters for all points. This value is roughly the global mean vlaue for the mixed layer depth as was determinded from the observations by Levitus (1982). . Redness of the SST anomalies . The standard deviation of the SST anoamlies do not aloine describe the large-scale character of the SST varaiblity. An important feature of the SSt variability is the increase of the variance in the SST power spectra with period, which is the so called redness of the spectra. If the SST anomalies follow an AR(1)-process than the redness can be estimated by the lag-1 correlation. . $C( omega) = frac{ sigma^2}{(1- alpha)^2+ omega^2}$ . $ sigma$ = standard deviation . $ omega$ = frequency . $ alpha$ = lag-1 correlation based on monthly mean time series . The increase of $C( omega)$ is only a function of $ alpha$, hence the redness $Q_{red}$ can be defined as . $Q_{red}$ = $ frac{1}{(1- alpha)^2}$ . Conclusions . fully coupled models are signifcantly different in terms of large-scale features of the SST variability than slab ocean models | only slab ocean models can be regarded as an AR(1) process | The diference between the AR(1)-process and the SST spectra in the simulations with fully dynamical ocean models is characterized by a slower increase of the SST variance from the shorter time periods to the longer time periods, which leads to increased variance of the SST on the seasonal and the decadal timescale relative to the fitted AR(1)-process. AMO and AMOC. . Simple red noise null hypothesis . c1 = 1 c2 = 0.86 c3 = 0.01 f, ax = plt.subplots(3, figsize = (12,4)) ax = ax.ravel() for realisation in range(0,3): white_noise_sequence = np.random.normal(0, 1, 1000) red_noise_sequence1 = np.zeros((len(white_noise_sequence))) red_noise_sequence2 = np.zeros((len(white_noise_sequence))) red_noise_sequence3 = np.zeros((len(white_noise_sequence))) for i in range(1, len(white_noise_sequence)): red_noise_sequence1[i] = c1 * red_noise_sequence1[i-1] + white_noise_sequence[i] red_noise_sequence2[i] = c2 * red_noise_sequence2[i-1] + white_noise_sequence[i] red_noise_sequence3[i] = c3 * red_noise_sequence3[i-1] + white_noise_sequence[i] ax[0].plot(red_noise_sequence1) ax[1].plot(red_noise_sequence2) ax[2].plot(red_noise_sequence3) .",
            "url": "https://florianboergel.github.io/personal_blog/jupyter/2020/11/05/red_noise_binder.html",
            "relUrl": "/jupyter/2020/11/05/red_noise_binder.html",
            "date": " • Nov 5, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Main site florianboergel.github.io [^1]. . On this side, you can find some code and lecture examples. .",
          "url": "https://florianboergel.github.io/personal_blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://florianboergel.github.io/personal_blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}