{
  
    
        "post0": {
            "title": "Snowball Earth, the ice-albedo feedback, and multiple equilibria",
            "content": "Thanks a lot to Henri Drake for providing the lecture. . The original lecture is part of the MIT class Introduction to Computational Thinking. . This class uses the Julia programming language. The orignal code can be found under https://github.com/hdrake/simplEarth/blob/master/1_energy_balance_model.jl . Snowball Earth, the ice-albedo feedback, and multiple equilibria . Source (New York Times) . import numpy as np import xarray as xr import matplotlib.pyplot as plt . 1) Background: Snowball Earth . Geological evidence shows that the Neoproterozoic Era (550 to 1000 million years ago) is marked by two global glaciation events, in which Earth&#39;s surface was covered in ice and snow from the Equator to the poles (see review by Pierrehumbert et al. 2011). . . In this lecture, we make a simple modification to our zero-dimensional energy balance model from Lecture 1 that will allow us to explore the processes behind these sudden glaciations. . . We can represent the ice-albedo feedback crudely in our energy balance model by allowing the albedo to depend on temperature: . $$ alpha(T) = begin{cases} alpha_{i} &amp; mbox{if } ; ; T leq -10 text{°C} &amp; text{(completely frozen)} alpha_{i} + ( alpha_{0}- alpha_{i}) frac{T + 10}{20} &amp; mbox{if } ; ; -10 text{°C} leq T leq 10 text{°C} &amp; text{(partially frozen)} alpha_{0} &amp; mbox{if } ; ; T geq 10 text{°C} &amp; text{(no ice)} end{cases}$$ 1.2) Adding the ice-albedo feedback to our simple climate model . First, we program albedo as a function of temperature. . def calc_alpha(T, alpha0, alphai = 0.5, deltaT=10.): if T &lt; - deltaT: return alphai elif -deltaT &lt;= T &lt; deltaT: return alphai + (alpha0 - alphai)*(T + deltaT) / (2*deltaT) elif T &gt;= deltaT: return alpha0 . calc_alpha_vec = np.vectorize(calc_alpha) # boolean evaluations need to be vectorized T_example = np.arange(-20, 20) plt.plot(T_example, calc_alpha_vec(T_example[:], 0.3), color = &quot;black&quot;) plt.ylim(0.2,0.6) plt.plot([-20, -10], [0.2, 0.2]) plt.fill_between([-20, -10], y1=0.2, y2=0.6, color = &quot;lightblue&quot;, alpha = 0.2) plt.fill_between([10, 20], y1=0.2, y2=0.6, color = &quot;red&quot;, alpha = 0.12) plt.ylabel(&quot;albedo $α$ n(planetary reflectivity)&quot;) plt.xlabel(&quot;Temperature [°C]&quot;) plt.text(-18.5, 0.252, s=&quot;completely nfrozen&quot;, size=10, color=&quot;darkblue&quot;) plt.text(-3, 0.252, s=&quot;partiall frozen&quot;, size=10, color=&quot;darkgrey&quot;) plt.text(13, 0.252, s=&quot;no ice&quot;, size=10, color=&quot;darkred&quot;) . Text(13, 0.252, &#39;no ice&#39;) . To add this function into our energy balance model from Lecture 1 (which we&#39;ve copied into the cell below), all we have to do is overwrite the definition of the timestep! method to specify that the temperature-dependent albedo should be updated based on the current state: . class ebm(): &quot;&quot;&quot; Zero order energy balance model &quot;&quot;&quot; def __init__(self, T, t, deltat, CO2): self.T = np.array(T) self.t = t self.deltat = deltat self.C = 51. self.a = 5. self.B = -1.3 self.co2_pi = 280. self.alpha = 0.3 self.S = 1368. self.co2 = CO2 self.CO2_PI = 280. self.A = 221.2 def absorbed_solar_radiation(self): return (self.S*(1-self.alpha2)/4.) # [W/m^2] def outgoing_thermal_radiation(self): if self.T.size == 1: return self.A - self.B*self.T else: return self.A - self.B*self.T[-1] def greenhouse_effect(self): if self.T.size == 1: return self.a*np.log(self.co2(self.t)/self.CO2_PI) else: return self.a*np.log(self.co2(self.t[-1])/self.CO2_PI) def tendency(self): if self.T.size == 1: return 1. / self.C * ( + self.absorbed_solar_radiation() - self.outgoing_thermal_radiation() + self.greenhouse_effect() ) else: return 1. / self.C * ( + self.absorbed_solar_radiation() - self.outgoing_thermal_radiation() + self.greenhouse_effect() ) def run(self, end_year): for year in range(end_year): self.timestep() def timestep(self): if self.T.size == 1: self.alpha2 = calc_alpha(self.T, alpha0=self.alpha) # Added the function call here self.T = np.append(self.T, self.T + self.deltat * self.tendency()) self.t = np.append(self.t, self.t + self.deltat) else: self.alpha2 = calc_alpha(self.T[-1], alpha0=self.alpha) # Added the function call here self.T = np.append(self.T, self.T[-1] + self.deltat * self.tendency()) self.t = np.append(self.t, self.t[-1] + self.deltat) . 2) Multiple Equilibria . OR: the existence of &quot;alternate Earths&quot; . Human civilization flourished over the last several thousand years in part because Earth&#39;s global climate has been remarkably stable and forgiving. The preindustrial combination of natural greenhouse effect and incoming solar radiation yielded temperatures between the freezing and boiling points of water across most of the planet, allowing ecoystems based on liquid water to thrive. . The climate system, however, is rife with non-linear effects like the ice-albedo effect, which reveal just how fragile our habitable planet is and just how unique our stable pre-industrial climate was. . We learned in Lecture 20 that in response to temperature fluctuations, net-negative feedbacks act to restore Earth&#39;s temperature back towards a single equilibrium state in which absorbed solar radiation is balanced by outgoing thermal radiation. Here, we explore how non-linear positive feedbacks can temporarily result in a net-positive feedback and modify Earth&#39;s state space. . def CO2_const(t): # define CO2 scenario return 280 . f, (ax) = plt.subplots(1, figsize = (8,8)) for count, T0_sample in enumerate(range(-60, 30, 5)): EBM = ebm(T0_sample, 0, 1., CO2_const) EBM.run(200) ax.plot(EBM.t, EBM.T) ax.fill_between([0, 200], y1=-60, y2=-10, color = &quot;lightblue&quot;, alpha = 0.2) ax.set_xlabel(&quot;year&quot;) ax.set_ylabel(&quot;Temperature [°C]&quot;) ax.set_ylim(-60,30) ax.text(120,-25, s=&quot;Completly frozen&quot;, size = 10, color = &quot;darkblue&quot;) ax.fill_between([0, 200], y1=10, y2=30, alpha=0.09, color=&quot;red&quot;) ax.text(120,20, s=&quot;no ice&quot;, size = 10, color = &quot;darkred&quot;) T_un = 7.5472 deltaTs = 1e-2*np.array([-2, -1., 0., 1., 2.]) for deltaT in deltaTs: ebm_un = ebm(T_un+deltaT, 0., 1, CO2_const) ebm_un.run(200) ax.plot(ebm_un.t, ebm_un.T, ls = &quot;--&quot;) ax.grid() ax.plot(200, 14, marker=&quot;o&quot;, label=&quot;Our pre-industrial climate (stable &#39;&#39;warm&#39;&#39; branch)&quot;, color=&quot;orange&quot;, markersize=8) ax.plot(200, -38.3, marker=&quot;o&quot;, label=&quot;Alternate universe pre-industrial climate (stable &#39;&#39;cold&#39;&#39; branch)&quot;, color=&quot;aqua&quot;, markersize=8) ax.plot(200, T_un, marker=&quot;o&quot;, label=&quot;Impossible alternate climate (unstable branch&quot;, color=&quot;lightgrey&quot;, markersize=8) ax.legend(loc=4) # plot!(p_equil, [200], [-38.3], markershape=:circle, label=&quot;Alternate universe pre-industrial climate (stable &#39;&#39;cold&#39;&#39; branch)&quot;, color=:aqua, markersize=8) # plot!(p_equil, [200], [T_un], markershape=:diamond, label=&quot;Impossible alternate climate (unstable branch)&quot;, color=:lightgrey, markersize=8, markerstrokecolor=:white, alpha=1., markerstrokestyle=:dash) . &lt;matplotlib.legend.Legend at 0x7fe047f95760&gt; . We see that for T₀ ⪆ 7.55 °C, all of the curves seem to converge on the T = 14°C equilibrium (or fixed point) that we saw in Lecture 20. Curves that start below this value warm up and while curves that start above this value will cool down. For T₀ ⪅ 7.55 °C, however, the temperatures converge on a much colder equilibrium around T = -40°C. This is the Snowball Earth equilibrium. These two states are referred to as stable equilibria because even if the state gets temporarily pushed slightly away from its equilibrium, it will eventually converge right back to its equilibrium. . So what happens is T₀ ≈ 7.55 °C? For some exact temperature near there, there is indeed an equilibrim state: if you start with that temperature you will stay there forever. However, if the temperature starts off even one one-hundredth of a degree above or below this exact value, we see that temperatures eventually converge to one of the other two equilibria. Thus, we call this intermediate equilibrium an unstable equilibrium, because any infinitesimal push away will cause it to careen away towards another state. . 2.2) Radiative stability analysis . We can understand why our model has two stable equilibria and one unstable equilibrium by applying concepts from dynamical systems theory. . Recall that, with fixed CO₂ concentrations, our energy balance model differential equation can be expressed as: . $$C frac{dT}{dT} = ASR(T) - OTR(T)$$, . where now the Absorbed Solar Radiatio (ASR) is also temperature dependent because the albedeo $ alpha (T)$ is. . In particular, by plotting the right-hand-side tendency terms as a function of the state variable $T$, we can plot a stability diagram for our system that tells us whether the plan will warm ($C frac{dT}{dt}$ &gt; 0) or cool ($C frac{dT}{dt}$ &lt; 0) . EBM = ebm(T_un, 0., 1, CO2_const) temp_range = np.arange(-60, 30) OTR, ASR = np.zeros((len(temp_range))), np.zeros((len(temp_range))) for count, i in enumerate(temp_range): EBM.T = np.array(i) EBM.alpha2 = calc_alpha(EBM.T, EBM.alpha) OTR[count] = EBM.outgoing_thermal_radiation() ASR[count] = EBM.absorbed_solar_radiation() imbalance = ASR - OTR . f, (ax, bx) = plt.subplots(1,2, figsize=(8,4)) ax.plot(temp_range, OTR, label= &quot;Outgoing Thermal Radiation&quot;) ax.plot(temp_range, ASR, label = &quot;Absorbed Solar Radiation&quot;) ax.set_xlabel(&quot;temperature [°C]&quot;) ax.set_ylabel(&quot;energy flux [W/$m^2$]&quot;) bx.fill_between([-60, 30], y1=0, y2=40, alpha=0.2, color=&quot;red&quot;) bx.fill_between([-60, 30], y1=-50, y2=0, alpha=0.2, color=&quot;blue&quot;) bx.set_xlabel(&quot;temperature [°C]&quot;) bx.set_ylabel(&quot;energy flux [W/$m^2$]&quot;) bx.set_ylim(-50,40) bx.plot(temp_range, imbalance, color = &quot;black&quot;, label = &quot;Radiative Imbalance n (ASR-OTR)&quot;) bx.text(-60, 35, &quot;warming&quot;, color =&quot;darkred&quot;, size = 12) bx.text(-60, -40, &quot;cooling&quot;, color =&quot;darkblue&quot;, size = 12) ax.legend(); bx.legend() ax.grid(); bx.grid() f.tight_layout() . 3) Transitioning to and from Snowball Earth . 3.1) Turning up the Sun . Over the entire history of the Earth, the Sun is thought to have brightened by about 40%. . . In the Neoproterozoic (~700 million years ago), the Sun was 93% as bright as it is today, such that the incoming solar radiation was $S$ = 1272 W/m², Earth&#39;s average temperature plunged to $T = -50$°C, and Earth&#39;s ice-covered surface had a high albedo (reflectivity) of $ alpha_i = 0.5$. . 3.2) Did the increasing brightness of the Sun melt the Snowball? . If we start out in the Neoproterozoic climate and all we do is increase solar insolation to today&#39;s value of 1368 W/m², can we warm the planet up to the pre-industrial temperature of °C? . smin = 1200 smax = 1800 smax_limited = 1650 svec = np.arange(smin, smax) svec = np.append(svec, svec[::-1]) tvec = np.zeros(svec.size) . t_restart = -100 for i, S in enumerate(svec): EBM = ebm(t_restart, 0., 5., CO2_const); EBM.S = S EBM.run(400) t_restart = EBM.T[-1] tvec[i] = EBM.T[-1] plt.plot(svec[0:len(svec)//2], tvec[0:len(svec)//2]) . [&lt;matplotlib.lines.Line2D at 0x7fe04c46dc40&gt;] . plt.plot(svec) . [&lt;matplotlib.lines.Line2D at 0x7fe04c3140a0&gt;] . plt.plot(svec,tvec) . [&lt;matplotlib.lines.Line2D at 0x7fe047b43880&gt;] . ebm_un = ebm(T_un, 0., 1, CO2_const) print(calc_alpha(ebm_un.T, ebm_un.alpha)) ebm_un.timestep() print(ebm_un.tendency().astype(&quot;float128&quot;)) print(calc_alpha(ebm_un.T[-1], 0.3)) # print(ebm_un.tendency()+ebm_un.T[-1]) # print(ebm_un.tendency(), ebm_un.alpha, ebm_un.absorbed_solar_radiation(), ebm_un.outgoing_thermal_radiation()) # print(ebm_un.t, ebm_un.T) . ebm_un.tendency() . calc_alpha(ebm_un.T[-1], ebm_un.alpha) . ebm_un.alpha = calc_alpha(7.5472, alpha0=0.3) . ebm_un.alpha . ebm_un.tendency() . EBM.absorbed_solar_radiation() EBM.t . begin p_equil = plot(xlabel=&quot;year&quot;, ylabel=&quot;temperature [°C]&quot;, legend=:bottomright, xlims=(0,205), ylims=(-60, 30.)) plot!([0, 200], [-60, -60], fillrange=[-10., -10.], fillalpha=0.3, c=:lightblue, label=nothing) annotate!(120, -20, text(&quot;completely frozen&quot;, 10, :darkblue)) plot!([0, 200], [10, 10], fillrange=[30., 30.], fillalpha=0.09, c=:red, lw=0., label=nothing) annotate!(120, 25, text(&quot;no ice&quot;, 10, :darkred)) for T0_sample in (-60.:5.:30.) ebm = Model.EBM(T0_sample, 0., 1., Model.CO2_const) Model.run!(ebm, 200) plot!(p_equil, ebm.t, ebm.T, label=nothing) end T_un = 7.5472 for δT in 1.e-2*[-2, -1., 0., 1., 2.] ebm_un = Model.EBM(T_un+δT, 0., 1., Model.CO2_const) Model.run!(ebm_un, 200) plot!(p_equil, ebm_un.t, ebm_un.T, label=nothing, linestyle=:dash) end plot!(p_equil, [200], [Model.T0], marker=:., label=&quot;Our pre-industrial climate (stable &#39;&#39;warm&#39;&#39; branch)&quot;, color=:orange, markersize=8) plot!(p_equil, [200], [-38.3], marker=:., label=&quot;Alternate universe pre-industrial climate (stable &#39;&#39;cold&#39;&#39; branch)&quot;, color=:aqua, markersize=8) plot!(p_equil, [200], [T_un], marker=:d, label=&quot;Impossible alternate climate (unstable branch)&quot;, color=:lightgrey, markersize=8, markerstrokecolor=:white, alpha=1., markerstrokestyle=:dash) p_equil end . 2) Multiple Equilibria . OR: the existence of &quot;alternate Earths&quot; . Human civilization flourished over the last several thousand years in part because Earth&#39;s global climate has been remarkably stable and forgiving. The preindustrial combination of natural greenhouse effect and incoming solar radiation yielded temperatures between the freezing and boiling points of water across most of the planet, allowing ecoystems based on liquid water to thrive. . The climate system, however, is rife with non-linear effects like the ice-albedo effect, which reveal just how fragile our habitable planet is and just how unique our stable pre-industrial climate was. . We know from Lecture 1 that in response to temperature fluctuations, negative feedbacks act to restore Earth&#39;s temperature back towards a single equilibrium state in which absorbed solar radiation is balanced by outgoing thermal radiation. .",
            "url": "https://florianboergel.github.io/personal_blog/jupyter/2020/11/12/ice-albedo.html",
            "relUrl": "/jupyter/2020/11/12/ice-albedo.html",
            "date": " • Nov 12, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "A "zero-dimensional" energy balance model of Earth's climate",
            "content": "Thanks a lot to Henri Drake for providing the lecture. . The original lecture is part of the MIT class Introduction to Computational Thinking. . This class uses the Julia programming language. The orignal code can be found under https://github.com/hdrake/simplEarth/blob/master/1_energy_balance_model.jl . import xarray as xr import numpy as np import matplotlib.pyplot as plt . 1) Background: climate physics . The simplest climate model can be conceptualized as: . change in heat content = . $+$ absorbed solar radiation (energy from the Sun&#39;s rays) . $-$ outgoing thermal radiation (i.e. blackbody cooling to space) . $+$ human-caused greenhouse effect (trapped outgoing radiation) . where each of these is interpreted as an average over the entire globe (hence &quot;zero-dimensional&quot;). . . To make this simple conceptual model quantitative, we need a mathematical formulation for each of these four processes. . 1.1 Absorbed solar radiation . At Earth&#39;s orbital distance from the Sun, the power of the Sun&#39;s rays that intercept the Earth is equal to . S = 1368 # solar insolation [W/m^2] (energy per unit time per unit area) . A small fraction . alpha = 0.3 # albedo, or planetary reflectivity [unitless] . of this incoming solar radiation is reflected back out to space (by reflective surfaces like white clouds, snow, and ice), with the remaining fraction $(1- alpha)$ being absorbed. Since the incoming solar rays are all approximately parallel this far from the Sun, the cross-sectional area of the Earth that intercepts them is just a disc of area $ pi R^{2}$. Since all of the other terms we will consider act on the entire surface area $4 pi R^{2}$ of the spherical Earth, the absorbed solar radiation per unit surface area (averaged over the entire globe) is reduced by a factor of 4. . . The absorbed solar radiation per unit area is thus . $ text{absorbed solar radiation} equiv frac{S(1- alpha)}{4}$ . def absorbed_solar_radiation(S, alpha): return (S*(1-alpha)/4) # [W/m^2] . 1.2) Outgoing thermal radiation . The outgoing thermal radiation term (or &quot;blackbody cooling to space&quot;) represents the combined effects of negative feedbacks that dampen warming, such as blackbody radiation, and positive feedbacks that amplify warming, such as the water vapor feedback. . Since these physics are too complicated to deal with here, we linearize the model by considering only the first term of a Taylor Series expansion . $$ G(T) sim G(T_0) + G^{&#39;}(T_0) (T-T_0) = G^{&#39;}(T_0)T + (G(T_0)-G^{&#39;}(T_0)T_0) $$ . around the pre-industrial equilibrium temperature . T0 = 14. # preindustrial temperature [°C] . To simplify the expression, we define: . $ A equiv G^{&#39;}(T_0)T_0 $ . $ B equiv - G^{&#39;}(T_0) text{ (the climate feedback parameter),}$ . which gives . $$ text{outgoing thermal radiation} equiv G(T) sim A - BT$$ . def outgoing_thermal_radiation(T, A, B): return A - B*T . The value of the climate feedback parameter used here, . B = -1.3 # climate feedback parameter [W/m^2/°C], . comes from a bottom-up estimate based on the best understanding of the various climate feedbacks (read more here). . Note: Since $B&lt;0$ , this tells us that the overall climate feedback is negative (i.e. stabilizing). Positivefeedbacks cause to become less negative, reducing the efficiency with which Earth cools itself by radiating thermal energy to space, and thus amplifying warming. . The value $A$ of is given by the definition of a preindustrial equilibrium, i.e. the fact that before human influence, Earth&#39;s energy budget was perfectly balanced: . absorbed solar radiation = outgoing thermal radiation . or . $ frac{S (1- alpha)}{4} equiv A - BT_0$ . By rearanging this equation, we find that the value of $A$ is given by . A = S*(1. - alpha)/4 + B*T0 # [W/m^2]. A . 221.2 . Human-caused greenhouse effect . Empirically, the greenhouse effect is known to be a logarithmic function of gaseous carbon dioxide (CO$_2$) concentrations . $$ text{Human-caused greenhouse effect} = a * ln frac{CO_2}{CO{_2}_{PI}} $$ . where . a = 5 # CO2 forcing coefficient [W/m^2] . CO2_PI = 280 # preindustrial CO2 concentration [parts per million; ppm]; . def greenhouse_effect(CO2, a=5, CO2_PI = 280): return a*np.log(CO2/CO2_PI) . co2_present = 420 co2_range = 280*2**np.linspace(-1,3,100) plt.plot(co2_range, greenhouse_effect(co2_range), color = &quot;black&quot;) plt.ylabel(&#39;Radiative forcing [$W/m^2$]&#39;) plt.xlabel(&#39;$CO_2$ concentration [ppm]&#39;) plt.plot(CO2_PI, greenhouse_effect(CO2_PI), marker=&quot;.&quot;, markersize = 20, label = &quot;pre-industrial (PI)&quot;, color = &quot;blue&quot;) plt.plot(co2_present, greenhouse_effect(co2_present), marker=&quot;.&quot;, markersize = 20, label = &quot;present day (2020)&quot;, color = &quot;red&quot;) plt.xticks([280, 280*2, 280*4, 280*8]) plt.legend(loc = 4) plt.grid() . 1.4) Change in heat content . The heat content $CT$ is determined by the temperature $T$ (in Kelvin) and the heat capacity of the climate system. While we are interested in the temperature of the atmosphere, which has a very small heat capacity, its heat is closely coupled with that of the upper ocean, which has a much larger heat capacity of . C = 51 . The change in heat content over time is thus simply given by $ frac{d(CT)}{dt}$. Since the heat capacity of sea water hardly changes with temperature, we can rewrite this in terms of the change in temperature with time as: . $$ text{change in heat content} = C frac{dT}{dt} $$ . 1.5) &quot;zero-dimensional&quot; climate model equation . Combining all of these subcomponent models, we write the governing equation of the &quot;zero-dimensional&quot; energy balance climate model as the Ordinary Differential Equation (ODE) . $$ C frac{dT}{dt} = frac{S (1- alpha)}{4} - ( A - BT_0) + a * ln frac{CO_2}{CO{_2}_{PI}} $$ . which determines the time evolution of Earth&#39;s globally-averaged surface temperature. . 2) Numerical solution method and data structures . 2.1) Discretization . The energy balance model equation above can be discretized in time as . $$ C frac{T(t+ Delta t) - T(t)}{ Delta t} = frac{S (1- alpha)}{4} - ( A - BT_0) + a * ln frac{CO_2}{CO{_2}_{PI}} $$ . Our finite difference equation, which results from a first-order truncation of the Taylor series expansion, approximates the exact ordinary differential equation above in the limit that $ Delta t rightarrow 0$. In practice, we can keep decreasing $ Delta t$ until the solution converges within a tolerable error. . Hereafter, we use the subscript $n$ to denote the $n$-th timestep, where $T_{n+1} equiv T(t_{n+1})$ denotes the temperature at the next timestep $t_{n+1} = t_n + Delta t$. . By re-arranging the equation, we can solve for the temperature at the next timestep $n+1$ based on the known temperature at the present timestep $n$: . $$ T_{n+1} = T_n + frac{ Delta t}{C} bigg[ frac{S (1- alpha)}{4} - ( A - BT_n) + a * ln frac{CO_2}{CO{_2}_{PI}} bigg] $$ . 2.2) Timestepping . More generally, we recognize this equation to be of the form: . $$ T_{n+1} = T_n + Delta t cdot text{tendency}(T_n; ...),$$ . which we implement below (don&#39;t forget to update the time as well, $t_{n+1} = t_n + Delta t$), which takes in an instance of our anticipated energy balance model EBM type as its only argument. . class ebm(): &quot;&quot;&quot; Zero order energy balance model &quot;&quot;&quot; def __init__(self, T, t, deltat, CO2): self.T = np.array(T) self.t = t self.deltat = deltat self.C = C self.a = a self.A = A self.B = B self.co2_pi = CO2_PI self.alpha = alpha self.S = S self.co2 = CO2 def tendency(self): if self.T.size == 1: return 1. / self.C * ( + absorbed_solar_radiation(alpha = self.alpha, S=self.S) - outgoing_thermal_radiation(self.T, A = self.A, B=self.B) + greenhouse_effect(self.co2(self.t), a = self.a, CO2_PI=self.co2_pi) ) else: return 1. / self.C * ( + absorbed_solar_radiation(alpha = self.alpha, S=self.S) - outgoing_thermal_radiation(self.T[-1], A = self.A, B=self.B) + greenhouse_effect(self.co2(self.t[-1]), a = self.a, CO2_PI=self.co2_pi) ) @property def timestep(self): if self.T.size == 1: self.T = np.append(self.T, self.T + self.deltat * self.tendency()) self.t = np.append(self.t, self.t + self.deltat) else: self.T = np.append(self.T, self.T[-1] + self.deltat * self.tendency()) self.t = np.append(self.t, self.t[-1] + self.deltat) . 2.4) Running simulations of the energy balance model . Let&#39;s define a function that runs an EBM simulation by timestepping forward until a given end_year. . def run_ebm(ebm, end_year): for year in range(end_year): ebm.timestep . For example, let us consider the case where CO₂ emissions increase by 1% year-over-year from the preindustrial value [CO$_2$] = $280.0$ ppm, starting at T=T₀=14°C in year t=0 and with a timestep Δt = 1 year. . def CO2_test(t): return CO2_PI ** (1 + 1/100)**t EBM = ebm(T0, t=0, deltat=1, CO2=CO2_test) . EBM.timestep . EBM.T . array([14., 14.]) . 3) Energy balance model applications . 3.1) Why was Earth&#39;s preindustrial climate so stable? . Let us consider the simple case where CO₂ concentrations remain at their pre-industrial temperatures. . def CO2_test(t): return 280 EBM = ebm(T0, 0, 1, CO2_test) . run_ebm(EBM, 200) . t0s = np.arange(0,28,2) for i in t0s: EBM = ebm(i, 0, 1, CO2_test) run_ebm(EBM, 200) plt.plot(EBM.T) plt.grid() plt.xlabel(&quot;year&quot;) plt.ylabel(&quot;temperature [°C]&quot;) . Text(0, 0.5, &#39;temperature [°C]&#39;) . This figure shows that, no matter where we start out, the overall negative feedbacks ($B&lt;0$) restore the temperature to the preindustrial equilibrum value of $T_0$ = 14.0 °C, over an exponential timescale of about 100 years. . 3.2) Historical global warming fueled by greenhouse gas emissions . Human greenhouse gas emissions have fundamentally altered Earth&#39;s energy balance, moving us away from the stable preindustrial climate of the past few thousand years. . Since human CO₂ emissions are the main driver of global warming, we expect that if we plug historical CO₂ increases into our model (&quot;forcing&quot; it), we should roughly reproduce the observed historical global warming. . The observed increase of CO2 concentrations can be fairly accurately modelled by the simple cubic formula below. . def co2_hist(t): return 280 * (1+ ((t-1850)/220)**3) . EBM = ebm(T0, 1850, 1, co2_hist) run_ebm(EBM, 170) . import pandas as pd url = &quot;https://data.giss.nasa.gov/gistemp/graphs/graph_data/Global_Mean_Estimates_based_on_Land_and_Ocean_Data/graph.txt&quot; temp = pd.read_csv(url, header = None, skiprows=5, index_col=0, delimiter=&quot; &quot;) temp = temp + 14.15 CO2_url = &quot;https://scrippsco2.ucsd.edu/assets/data/atmospheric/stations/in_situ_co2/monthly/monthly_in_situ_co2_mlo.csv&quot; co2_data = pd.read_csv(CO2_url, header = 46,skiprows=8, index_col=0) co2_data = co2_data.iloc[4:] co2_data = pd.to_numeric(co2_data.iloc[:,5]) co2_data[co2_data&lt;= 0] = np.nan co2_data.index = pd.to_datetime(co2_data.index) co2_data = co2_data.groupby(co2_data.index.year).mean() . &lt;ipython-input-35-ad0381c77880&gt;:3: ParserWarning: Falling back to the &#39;python&#39; engine because the &#39;c&#39; engine does not support regex separators (separators &gt; 1 char and different from &#39; s+&#39; are interpreted as regex); you can avoid this warning by specifying engine=&#39;python&#39;. temp = pd.read_csv(url, header = None, . f, (ax, bx) = plt.subplots(1,2, figsize=(8,4)) ax.plot(np.arange(1850, 2020), co2_hist(np.arange(1850, 2020)), label = &quot;EBM model&quot;) ax.plot(co2_data.index, co2_data.values, label=&quot;Keeling Curve&quot;) ax.set_ylabel(&quot;$CO_2$ concentration [ppm]&quot;) ax.grid() ax.set_xlabel(&quot;Year&quot;) ax.legend() bx.plot(np.arange(1850, 2021), EBM.T, label=&quot;EBM model&quot;) temp.plot(ax = bx) bx.set_ylabel(&quot;Temperature [°C]&quot;) bx.grid() bx.legend([&quot;EBM Model&quot;, &quot;NASA Observations&quot;, &quot;NASA Obs roll. mean&quot;]) bx.set_xlabel(&quot;Year&quot;) f.tight_layout() . CO&#8322; emissions predict the trend, but what about the climate noise? . CO$_2$ emissions predict the trend, but what about the climate noise? Our model does a good job of predicting the long-term trend of increasing temperatures, but what about all of the noise in the observations? These are real signals due to natural variability of the Earth system, not artifacts due to instrumental noise. . This natural noise arises due to the turbulent and chaotic fluid dynamics of the atmosphere and ocean, which we will explore further in Lecture 4 and are illustrated below. . Now that we&#39;ve convinced ourselves that the model accurately reproduces historical warming, we can use it to project how much warming we might expect due to future CO₂ emissions. . 3.3) Best- and worst-case projections of future global warming . Consider two divergent hypothetical futures: . 1) a low-emissions world in which emissions decrease such that CO2 concentrations stay below 500 ppm by 2100 (known in climate circles as &quot;RCP2.6&quot;) and . 2) a high-emissions world in which emissions continue increasing and CO2 concentrations soar upwards of 1200 ppm (&quot;RCP8.5&quot;). . def CO2_RCP26(t): return 280 * (1+ ((t-1850)/220)**3 * np.minimum(1., np.exp(-((t-1850)-170)/100))) def CO2_RCP85(t): return 280 * (1+ ((t-1850)/220)**3 * np.maximum(1., np.exp(((t-1850)-170)/100))) . In the low-emissions scenario, the temperature increase stays below $ Delta T$ = 2 °C by 2100, while in the high-emissions scenario temperatures soar upwards of 3.5ºC above pre-industrial levels. . EBM1 = ebm(T0, 1850, 1, CO2_RCP26) EBM2 = ebm(T0, 1850, 1, CO2_RCP85) run_ebm(EBM1, 249) run_ebm(EBM2, 249) . f, (ax, bx) = plt.subplots(1,2, figsize = (8,4)) ax.plot(np.arange(1850, 2100), CO2_RCP26(np.arange(1850,2100)), color = &quot;Blue&quot;, label = &quot;RCP 2.6 low emissions&quot;) ax.plot(np.arange(1850, 2100), CO2_RCP85(np.arange(1850,2100)), color = &quot;Red&quot;, label = &quot;RCP 8.5 High emissions&quot;) ax.plot(2020, CO2_RCP26(2020), marker=&quot;.&quot;, markersize = 20, label = &quot;we are here&quot;, color = &quot;black&quot;) ax.set_ylabel(&quot;$CO_2$ concentration [ppm]&quot;) ax.legend() bx.plot(np.arange(1850, 2100), EBM1.T, color = &quot;Blue&quot;) bx.plot(np.arange(1850, 2100), EBM2.T, color = &quot;Red&quot;) bx.axhline(y = 16, label = &quot;Paris Agreement n threshold (2°C warming)&quot;, ls=&quot;--&quot;, color = &quot;black&quot;) bx.set_ylabel(&quot;Temperature [°C]&quot;) bx.plot(2020, EBM1.T[170], marker=&quot;.&quot;, markersize = 20, label = &quot;we are here&quot;, color = &quot;black&quot;) bx.legend() f.tight_layout() .",
            "url": "https://florianboergel.github.io/personal_blog/jupyter/2020/11/11/energy-model.html",
            "relUrl": "/jupyter/2020/11/11/energy-model.html",
            "date": " • Nov 11, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Introduction to python",
            "content": "Getting started . Introduction to Python . What are we doing during the course? . The course aims to introduce you to the first steps of data analysis . save data | organize and manipulate data | further tools for data analysis | . If you never coded before than starting with Python is perfect! Python is one of the easiest and most straight forward languages. . x = 1 . x = &quot;abcd&quot; . x as an integer and then a string? The same concept is applicable for many other different examples. Python has a minimalistic approech and follows a simple syntax. This is why source code is very easy to read. . x = 0 if x &gt; 0: statement = &quot;x is positive&quot; elif x &lt; 0: statement = &quot;x is negative&quot; else: statement = &quot;x is zero or none&quot; print(statement) . x is zero or none . x = 5 - 4 # Comments are made with a hash Raute y = &quot;Hello&quot; # Everything after the hash will be a comment if y == &quot;hallo&quot;: z = x * 2 y = y + &quot; World&quot; # This is how you combine strings! print(&quot;x :&quot;, x) # The letter x and the our variable x print(&quot;y :&quot;, y) print(&quot;z :&quot;, z) . x : 1 y : Hello . NameError Traceback (most recent call last) &lt;ipython-input-4-5a2e8fe8a7fe&gt; in &lt;module&gt; 7 print(&#34;x :&#34;, x) # The letter x and the our variable x 8 print(&#34;y :&#34;, y) -&gt; 9 print(&#34;z :&#34;, z) NameError: name &#39;z&#39; is not defined . First summary: . Indenting of the source code has a meaning! the indentation of your code organizes it into blocks within blocks within blocks. | . | the first assignment of a variable creates it we don&#39;t care if it is an integer, float or string | . | assignments of variables use =, to compare two variables we use == | also: logical operators are words (and, or, not) not symbols | . Variables and types . Variable . The value of a variable can be obtained by writing its name. . height = 1.79 weight = 68.7 weight . 68.7 . Second example: . Calculate your BMI . BMI = $ frac{weight [kg]}{size^2 [m]}$ . Exponentiation in Python is defined as . Variable ** 2 . . BMI = 60/(1.65**2) print(BMI) . 22.03856749311295 . Types . Without going into detail: . pi = 3.141516546859754674896794 days_of_week = 5 x = &#39;Hey Guys&#39; y = &quot;Also works this way ...&quot; z = True print(&#39;days_of_week: &#39;, type(days_of_week)) print(&#39;pi: &#39;, type(pi)) print(&#39;x: &#39;, type(x)) print(&#39;y: &#39;, type(y)) print(&#39;z: &#39;, type(z)) . days_of_week: &lt;class &#39;int&#39;&gt; pi: &lt;class &#39;float&#39;&gt; x: &lt;class &#39;str&#39;&gt; y: &lt;class &#39;str&#39;&gt; z: &lt;class &#39;bool&#39;&gt; . Does this really matter? Actually, no, since Python&#39;s use of variables is very intuitive. Still, keep in mind that a different variable type can lead to different behaviour: . 2 + 3 . 5 . &#39;ab&#39; + &#39;cd&#39; . &#39;abcd&#39; . a = 1 b = 5 c = a / b . What is the value of c? . print(c) . 0.2 . Lists . As opposed to int, bool etc., a list is a compound data type; you can group values together: . a = &quot;is&quot; b = &quot;nice&quot; my_list = [&quot;my&quot;, &quot;list&quot;, a, b] . After measuring the height of your family, you decide to collect some information on the house you&#39;re living in. The areas of the different parts of your house are stored in separate variables for now, as shown in the script. . List of lists . As a data scientist, you&#39;ll often be dealing with a lot of data, and it will make sense to group some of this data. . Instead of creating a flat list containing strings and floats, representing the names and areas of the rooms in your house, you can create a list of lists. The script on the right can already give you an idea. . Don&#39;t get confused here: &quot;hallway&quot; is a string, while hall is a variable that represents the float 11.25 you specified earlier. . hall = 11.25 kit = 18.0 liv = 20.0 bed = 10.75 bath = 9.50 # house information as list of lists house = [[&quot;hallway&quot;, hall], [&quot;kitchen&quot;, kit], [&quot;living room&quot;, liv]] # Print out house # Print out the type of house . Subset and conquer . Subsetting Python lists is a piece of cake. Take the code sample below, which creates a list x and then selects &quot;b&quot; from it. Remember that this is the second element, so it has index 1. You can also use negative indexing. . x = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] x[1] x[-3] # same result! . Remember the areas list from before, containing both strings and floats? Its definition is already in the script. Can you add the correct code to do some Python subsetting? . Familiar functions . Out of the box, Python offers a bunch of built-in functions to make your life as a data scientist easier. You already know two such functions: print() and type(). You&#39;ve also used the functions str(), int(), bool() and float() to switch between data types. These are built-in functions as well. . Calling a function is easy. To get the type of 3.0 and store the output as a new variable, result, you can use the following: . result = type(3.0) . The general recipe for calling functions and saving the result to a variable is thus: . output = function_name(input) . var1 = [1, 2, 3, 4] var2 = False # Print out type of var1 print(type(var1)) # Print out length of var1 print(len(var1)) # Convert var2 to an integer: out2 int(var2) . &lt;class &#39;list&#39;&gt; 4 . 0 . Numpy . import numpy as np # List a = [1,2,3,4,5,6,7,8,9] # numpy array A = np.array([1,2,3,4,5,6,7,8,9]) print(&quot;This is a list: {} and looks like n {}&quot;.format(type(a), a)) print(&quot;This is an array: {} and looks like n {}&quot;.format(type(A), A)) . This is a list: &lt;class &#39;list&#39;&gt; and looks like [1, 2, 3, 4, 5, 6, 7, 8, 9] This is an array: &lt;class &#39;numpy.ndarray&#39;&gt; and looks like [1 2 3 4 5 6 7 8 9] . Create arrays of a give length . y_ar = np.arange(0, 1, 0.1) print(&quot;Lenght of array y_ar is {}.&quot;.format(len(y_ar))) print(y_ar) x_ar = np.linspace(1, 10, 5) #creates an array of length 5 between 1 and 10 print(&quot;Lenght of array x_ar is {}.&quot;.format(len(x_ar))) print(x_ar) . Lenght of array y_ar is 10. [0. 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9] Lenght of array x_ar is 5. [ 1. 3.25 5.5 7.75 10. ] . Multidimensional arrays . z_ar = np.zeros((100)) #creates an array of shape (100,) with zeros print(&quot;Shape of z_ar is {}&quot;.format(z_ar.shape)) z_ar = np.zeros((100,1)) print(&quot;Shape of z_ar is {}&quot;.format(z_ar.shape)) z_ar = np.zeros((100, 1, 3, 5)) print(&quot;Shape of z_ar is {}&quot;.format(z_ar.shape)) z_ar[0, 0, 1, 2] . Shape of z_ar is (100,) Shape of z_ar is (100, 1) Shape of z_ar is (100, 1, 3, 5) . 0.0 . .shape gives you the dimensions of the array, while len() only returns the lenght of the first dimension! . import time a = [1, 2, 3] b = [3, 4, 5] print(a + b) c = [] for count in range(len(a)): c.append(a[count] + b [count]) print(c) . [1, 2, 3, 3, 4, 5] [4, 6, 8] . a = np.array([1., 2., 3.]) b = np.array([3., 4., 5.]) print(a + b) . [4. 6. 8.] . Why do we do this? . a = [1 for x in range(1000000)] b = [1 for x in range(1000000)] time1 = time.time() c = [] for count in range(len(a)): c.append(a[count] + b[count]) time2 = time.time() print(&#39;This took %0.3f ms&#39; % ((time2-time1)*1000.0)) a = np.ones(1000000) b = np.ones(1000000) time1 = time.time() c = a + b time2 = time.time() print(&#39;This took %0.3f ms&#39; % ((time2-time1)*1000.0)) . This took 143.381 ms This took 4.008 ms . Useful functions: . z = np.random.rand(10, 20, 30) print(z.shape) . (10, 20, 30) . z_mean = np.nanmean(z, axis = 1) print(z_mean.shape) z_mean = np.nanmean(z, axis = (1,2)) print(z_mean.shape) z_mean_sqrt = np.sqrt(z_mean) # square root . (10, 30) (10,) . masked arrays . z = np.random.rand(20, 20) mask = (z &lt; 0.5) print(mask) print(mask.shape) . [[ True True False True False False True False False False True True True True True True False False True False] [ True False False True False True True False True False True False False True False True False True True True] [False True False False False False True False True False False False True False False False True True False True] [False True False True False True False False True True False True False False True False False True True True] [False False True True False False False True False False True True True True False True False True False False] [ True False True False False True False False True True False True True False True True True False False True] [ True True True False True True False False False True False False False True True False True False False False] [ True True False True False False False True False False True True True False True True False False False True] [ True False True False False True False False True False False False False False False True False False True False] [False False False False True True True True True False True False False True True True True False False False] [False False False False True False False True False False False True True True False False True False True False] [False False True False False False False True True True False True True False True False False False True True] [ True True True True False True True True False True True False True True True True True True True True] [False False False True False True False False True True False True True False True True True True True False] [ True True False False True True True True True True True False False True True True True True True False] [False True False True False False False True True True False False True False False True True True True True] [ True False True False True True True True True True True True True True False False False True True True] [False False True True False True True False True False False False False False True False False False True False] [False False True False False True False True False True False False False True True False True False True False] [False True True False True True False False False True True False False False True True False True False True]] (20, 20) . z_masked = np.ma.asarray(z) z_masked.mask = mask print(z_masked) . [[-- -- 0.6841322664868621 -- 0.922084947777805 0.7446009976382294 -- 0.7827805791373229 0.7971243867987833 0.5008260556050257 -- -- -- -- -- -- 0.6735537444766054 0.5358929497913643 -- 0.8489044272309081] [-- 0.6800037484321665 0.8266756468477693 -- 0.5388515328063647 -- -- 0.9515762731730272 -- 0.8840169477520212 -- 0.7369442570400735 0.6807593131274697 -- 0.6525944034525066 -- 0.8471482174711514 -- -- --] [0.9771787554812514 -- 0.804611238115869 0.7893765830568098 0.9540930413449211 0.9902687233081275 -- 0.829529027338454 -- 0.5717564992951976 0.6635239745243123 0.615208220917845 -- 0.878800126258606 0.7781353206135389 0.7458498824914654 -- -- 0.6257101275566571 --] [0.6216854116046361 -- 0.973184947440456 -- 0.7180256521994817 -- 0.9961750485036727 0.5838352069642947 -- -- 0.6215821236264462 -- 0.6425006808645606 0.663716936905337 -- 0.7725837009477233 0.9260718492377176 -- -- --] [0.6389816542303868 0.554236143052863 -- -- 0.5373383058799038 0.5831432938259806 0.5822614668091846 -- 0.6338142919763412 0.5719659712392372 -- -- -- -- 0.870754825753243 -- 0.9599691122518207 -- 0.7025000820263061 0.9374740671741782] [-- 0.9480484885509206 -- 0.7679229377981068 0.5279372611338258 -- 0.7180822211609827 0.9135918307483372 -- -- 0.6976257298034473 -- -- 0.9936076763793273 -- -- -- 0.6263660577018085 0.6503124708718018 --] [-- -- -- 0.777713789747942 -- -- 0.8032300716226733 0.7336345587942362 0.6662032730981201 -- 0.783046444836236 0.5953075980413747 0.9296376957988014 -- -- 0.8986341386567844 -- 0.6938528876894814 0.5295528482850717 0.5454559913280633] [-- -- 0.6908198867337735 -- 0.521733907698779 0.8957337028754406 0.8453002514451121 -- 0.5114220926551898 0.6046337483236444 -- -- -- 0.7677555648295635 -- -- 0.5345404205577835 0.5359697853084991 0.8259964290402863 --] [-- 0.9608611859678965 -- 0.9178406291620897 0.7043167846789729 -- 0.8305027378881086 0.7665696163210567 -- 0.7088099859856594 0.6876612709123968 0.8854894873916885 0.8109058992361471 0.8468819605188486 0.75428231750394 -- 0.655255564055812 0.9197842566134002 -- 0.6053234460338283] [0.6869136317327381 0.6313372459495143 0.5184839836903395 0.9377490768479089 -- -- -- -- -- 0.7323068951962555 -- 0.6126984421358249 0.5810299281372328 -- -- -- -- 0.8463804257205332 0.9945170029452226 0.7747368367179134] [0.8184563481834909 0.7890771774663968 0.6307271241288201 0.8302472541394189 -- 0.508479764992007 0.536458529872816 -- 0.5974564788696255 0.9521117061023048 0.6825228877107221 -- -- -- 0.7938795427860159 0.967033201818732 -- 0.8023165507919235 -- 0.7794349829596751] [0.8464036965028987 0.7258645497981728 -- 0.5656402073082591 0.9595101785965126 0.8200078917432821 0.7081268178662556 -- -- -- 0.5606241087377087 -- -- 0.590694135970844 -- 0.6430377477150988 0.983463637715911 0.6003911430173208 -- --] [-- -- -- -- 0.6747958299205198 -- -- -- 0.6843340670035695 -- -- 0.7425681845655598 -- -- -- -- -- -- -- --] [0.9626769908320265 0.8763418320909225 0.5351375787160363 -- 0.5096350957658461 -- 0.6178506377691309 0.8144372179873651 -- -- 0.6100138144273485 -- -- 0.9406448185812636 -- -- -- -- -- 0.8020587720064528] [-- -- 0.7250889594732423 0.7147818904357396 -- -- -- -- -- -- -- 0.6730337499403024 0.8970205009186014 -- -- -- -- -- -- 0.6292377308536763] [0.6957793666920037 -- 0.7507575529584984 -- 0.7076385324027625 0.7659219689539477 0.5754453610976844 -- -- -- 0.8720746605258672 0.7913116080423563 -- 0.7193812652121355 0.8995382811531292 -- -- -- -- --] [-- 0.7189607728988828 -- 0.8435440805320096 -- -- -- -- -- -- -- -- -- -- 0.6003858302643601 0.9380843858956903 0.7818744529390556 -- -- --] [0.6529985115231637 0.5192980115023322 -- -- 0.8210921040944963 -- -- 0.9548222990765521 -- 0.6203801267211065 0.6747443287143892 0.9772520588854076 0.5566773754481543 0.5042223831572681 -- 0.8110370145492511 0.9852270232880322 0.9318833659633642 -- 0.6624951876797617] [0.977418369924988 0.5002475118520036 -- 0.5174031790609489 0.7562735331193595 -- 0.9919351106779605 -- 0.6012770864240572 -- 0.5072821007075403 0.6698976147029279 0.9220383089447005 -- -- 0.5284514437542255 -- 0.5159783430781271 -- 0.596425900421258] [0.9394487527383749 -- -- 0.5617270284658556 -- -- 0.602892605050211 0.5331939687015427 0.6499712315639927 -- -- 0.8372443246058571 0.9923984505436153 0.9018847725178546 -- -- 0.5365824193537669 -- 0.9014686006095781 --]] . import matplotlib.pyplot as plt . plt.pcolor(z) . &lt;matplotlib.collections.PolyCollection at 0x7f126a118790&gt; . plt.pcolor(z_masked) . &lt;matplotlib.collections.PolyCollection at 0x7f126a05a1c0&gt; . Functions . def multiply_constant(x, constant = 5): return x * constant print(multiply_constant(5)) print(multiply_constant(5, 3)) print(multiply_constant(x = 5, constant = 3)) print(multiply_constant(a, constant = 2.5)) . 25 15 15 [2.5 2.5 2.5 ... 2.5 2.5 2.5] . Data visualization . 1D Plot . import numpy as np import matplotlib.pyplot as plt import pandas as pd x = np.arange(0,300) # Numbers from 0 to 30 (30 not included) y = np.sin(np.arange(0,300)) + np.random.normal(0,5,300) # Create sinus ##signal and add noise dataFrame = pd.DataFrame({&#39;Intervals&#39;: x, &#39;values&#39;: y}) rolling_mean = dataFrame[&#39;values&#39;].rolling(10, min_periods=1, center=True).mean() plt.plot(x,y,label=&#39;Kurve&#39;, alpha=0.5) plt.plot(x, rolling_mean.values, label = &#39;Rolling Mean&#39;) plt.title(&#39;Sinus + Random&#39;) plt.xlabel(&#39;Interval&#39;) plt.ylabel(&#39;Values&#39;) plt.legend() . &lt;matplotlib.legend.Legend at 0x7f126a004a30&gt; . 2D Plots . z = np.random.rand(20,20) levels = np.linspace(0, 1, 10) f, ax = plt.subplots(1) im = ax.pcolor(z) #im = ax.contourf(z, levels = levels) #ax.contour(z) ax.set_title(&#39;Random Noise from 0 - 1&#39;) f.colorbar(im) . &lt;matplotlib.colorbar.Colorbar at 0x7f1267c00a00&gt; . netCDF4-files . import xarray as xr url = &quot;https://ds.nccs.nasa.gov/thredds/dodsC/CMIP5/ESGF/GISS/rcp45/E2-R_rcp45_r6i1p3_day/tos_day_GISS-E2-R_rcp45_r6i1p3_20910101-21001231.nc&quot; ds = xr.open_dataset(url) . ds.isel(time = 1) . Show/Hide data repr . . . Show/Hide attributes . . . . xarray.DatasetDimensions:bnds: 2 | lat: 90 | lon: 144 | . | Coordinates: (3)time()object2091-01-02 12:00:00bounds :time_bndsaxis :Tlong_name :timestandard_name :timearray(cftime.DatetimeNoLeap(2091-01-02 12:00:00), dtype=object) . | lat(lat)float64-89.0 -87.0 -85.0 ... 87.0 89.0bounds :lat_bndsunits :degrees_northaxis :Ylong_name :latitudestandard_name :latitudearray([-89., -87., -85., -83., -81., -79., -77., -75., -73., -71., -69., -67., -65., -63., -61., -59., -57., -55., -53., -51., -49., -47., -45., -43., -41., -39., -37., -35., -33., -31., -29., -27., -25., -23., -21., -19., -17., -15., -13., -11., -9., -7., -5., -3., -1., 1., 3., 5., 7., 9., 11., 13., 15., 17., 19., 21., 23., 25., 27., 29., 31., 33., 35., 37., 39., 41., 43., 45., 47., 49., 51., 53., 55., 57., 59., 61., 63., 65., 67., 69., 71., 73., 75., 77., 79., 81., 83., 85., 87., 89.]) . | lon(lon)float641.25 3.75 6.25 ... 356.2 358.8bounds :lon_bndsunits :degrees_eastaxis :Xlong_name :longitudestandard_name :longitudearray([ 1.25, 3.75, 6.25, 8.75, 11.25, 13.75, 16.25, 18.75, 21.25, 23.75, 26.25, 28.75, 31.25, 33.75, 36.25, 38.75, 41.25, 43.75, 46.25, 48.75, 51.25, 53.75, 56.25, 58.75, 61.25, 63.75, 66.25, 68.75, 71.25, 73.75, 76.25, 78.75, 81.25, 83.75, 86.25, 88.75, 91.25, 93.75, 96.25, 98.75, 101.25, 103.75, 106.25, 108.75, 111.25, 113.75, 116.25, 118.75, 121.25, 123.75, 126.25, 128.75, 131.25, 133.75, 136.25, 138.75, 141.25, 143.75, 146.25, 148.75, 151.25, 153.75, 156.25, 158.75, 161.25, 163.75, 166.25, 168.75, 171.25, 173.75, 176.25, 178.75, 181.25, 183.75, 186.25, 188.75, 191.25, 193.75, 196.25, 198.75, 201.25, 203.75, 206.25, 208.75, 211.25, 213.75, 216.25, 218.75, 221.25, 223.75, 226.25, 228.75, 231.25, 233.75, 236.25, 238.75, 241.25, 243.75, 246.25, 248.75, 251.25, 253.75, 256.25, 258.75, 261.25, 263.75, 266.25, 268.75, 271.25, 273.75, 276.25, 278.75, 281.25, 283.75, 286.25, 288.75, 291.25, 293.75, 296.25, 298.75, 301.25, 303.75, 306.25, 308.75, 311.25, 313.75, 316.25, 318.75, 321.25, 323.75, 326.25, 328.75, 331.25, 333.75, 336.25, 338.75, 341.25, 343.75, 346.25, 348.75, 351.25, 353.75, 356.25, 358.75]) . | . | Data variables: (4)time_bnds(bnds)object...array([cftime.DatetimeNoLeap(2091-01-02 00:00:00), cftime.DatetimeNoLeap(2091-01-03 00:00:00)], dtype=object) . | lat_bnds(lat, bnds)float64...array([[-90., -88.], [-88., -86.], [-86., -84.], [-84., -82.], [-82., -80.], [-80., -78.], [-78., -76.], [-76., -74.], [-74., -72.], [-72., -70.], [-70., -68.], [-68., -66.], [-66., -64.], [-64., -62.], [-62., -60.], [-60., -58.], [-58., -56.], [-56., -54.], [-54., -52.], [-52., -50.], [-50., -48.], [-48., -46.], [-46., -44.], [-44., -42.], [-42., -40.], [-40., -38.], [-38., -36.], [-36., -34.], [-34., -32.], [-32., -30.], [-30., -28.], [-28., -26.], [-26., -24.], [-24., -22.], [-22., -20.], [-20., -18.], [-18., -16.], [-16., -14.], [-14., -12.], [-12., -10.], [-10., -8.], [ -8., -6.], [ -6., -4.], [ -4., -2.], [ -2., 0.], [ 0., 2.], [ 2., 4.], [ 4., 6.], [ 6., 8.], [ 8., 10.], [ 10., 12.], [ 12., 14.], [ 14., 16.], [ 16., 18.], [ 18., 20.], [ 20., 22.], [ 22., 24.], [ 24., 26.], [ 26., 28.], [ 28., 30.], [ 30., 32.], [ 32., 34.], [ 34., 36.], [ 36., 38.], [ 38., 40.], [ 40., 42.], [ 42., 44.], [ 44., 46.], [ 46., 48.], [ 48., 50.], [ 50., 52.], [ 52., 54.], [ 54., 56.], [ 56., 58.], [ 58., 60.], [ 60., 62.], [ 62., 64.], [ 64., 66.], [ 66., 68.], [ 68., 70.], [ 70., 72.], [ 72., 74.], [ 74., 76.], [ 76., 78.], [ 78., 80.], [ 80., 82.], [ 82., 84.], [ 84., 86.], [ 86., 88.], [ 88., 90.]]) . | lon_bnds(lon, bnds)float64...array([[ 0. , 2.5], [ 2.5, 5. ], [ 5. , 7.5], ..., [352.5, 355. ], [355. , 357.5], [357.5, 360. ]]) . | tos(lat, lon)float32...standard_name :surface_temperaturelong_name :Sea Surface Temperaturecomment :temperature of liquid ocean. Note that the correct standard_name for this variable is &quot;&quot;sea_surface_temperature&quot;&quot;, not &quot;&quot;surface_temperature&quot;&quot;, but this was discovered too late to correct. To maintain consistency across CMIP5 models, the wrong standard_name will continue to be used.units :Koriginal_name :dummycell_methods :time: meancell_measures :area: areacellohistory :2012-09-27T15:35:07Z altered by CMOR: replaced missing value flag (-1e+30) with standard missing value (1e+20).associated_files :baseURL: http://cmip-pcmdi.llnl.gov/CMIP5/dataLocation gridspecFile: gridspec_ocean_fx_GISS-E2-R_rcp45_r0i0p0.nc areacello: areacello_fx_GISS-E2-R_rcp45_r0i0p0.ncarray([[ nan, nan, nan, ..., nan, nan, nan], [ nan, nan, nan, ..., nan, nan, nan], [ nan, nan, nan, ..., nan, nan, nan], ..., [271.45233, 271.45172, 271.49725, ..., 271.50067, 271.48697, 271.47012], [271.5155 , 271.50873, 271.50183, ..., 271.53275, 271.52777, 271.5219 ], [271.56015, 271.56015, 271.56015, ..., 271.56015, 271.56015, 271.56015]], dtype=float32) . | . | Attributes: (28)institution :NASA/GISS (Goddard Institute for Space Studies) New York, NYinstitute_id :NASA-GISSexperiment_id :rcp45source :GISS-E2-R-E134TcadiRCP45fF40oQ32 Atmosphere: GISS-E2; Ocean: Rmodel_id :GISS-E2-Rforcing :GHG, LU, Sl, Vl, BC, OC, SA, Oz (also includes orbital change - BC on snow - Nitrate aerosols - interactive CH4)parent_experiment_id :historicalparent_experiment_rip :r6i1p3branch_time :2006.0contact :Kenneth Lo (cdkkl@giss.nasa.gov)references :http://data.giss.nasa.gov/modelE/ar5initialization_method :1physics_version :3tracking_id :b2041a15-ef72-4217-914e-fbbb361a5f72product :outputexperiment :RCP4.5frequency :daycreation_date :2012-09-27T15:35:07Zhistory :2012-09-27T15:35:07Z CMOR rewrote data to comply with CF standards and CMIP5 requirements.Conventions :CF-1.4project_id :CMIP5table_id :Table day (27 April 2011) 86d1558d99b6ed1e7a886ab3fd717b58title :GISS-E2-R model output prepared for CMIP5 RCP4.5parent_experiment :historicalmodeling_realm :oceanrealization :6cmor_version :2.5.7DODS_EXTRA.Unlimited_Dimension :time | . ds.isel(time = 1).tos.plot() . &lt;matplotlib.collections.QuadMesh at 0x7f1264c220a0&gt; . ds.sel(lon = slice(150,200)).isel(time = 1).tos.plot() . &lt;matplotlib.collections.QuadMesh at 0x7f1264b4c5b0&gt; .",
            "url": "https://florianboergel.github.io/personal_blog/jupyter/2020/11/09/introduction_to_python.html",
            "relUrl": "/jupyter/2020/11/09/introduction_to_python.html",
            "date": " • Nov 9, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Red noise",
            "content": "Hasselmann (as explained by Dommenget and Latif, 2000) . Hasselmann (1976) attempts to explain the mechanism of natural climate variabilty by dividing the climate system into a fast system and a slow system. The fast system could be the atmosphere, represented as white noise. The slower component is the ocean and is explained by the integration of white noise (AR-1). In this picture the ocean is merely a passive part of the climate system, which amplifies long-term variability, due to its large heat capacity, but dynamical processes in the ocean are not considered. . The resulting stochastic model of the SST variability is described by an autoregressive process of the first order, which is the simplest statistical model that can be applied to a stationary process. The stochastic climate model by Hasselmann is tehrefore often chosen as the null hypothesis of SST variability. . Slab ocean-atmosphere models can be regarded as a numerical realization of the null hypothesis (AR(1)-process) of Hasselmann&#39;s stochastic climate model. . The null hypothesis of SST variability in the midlatitudes, described by Hasselmann&#39;s stochastic climate model, assumes that the SST variability is well described by the integration of the atmospheric heat flux with the heat capacity of the ocean&#39;s mixed layer. . $ frac{d SST}{dT} = frac{1}{C_p rho_w d_{mix}}* F + Delta T_c$ . $C_p$ = specifc heat of sea water . $ rho_w$ = density of sea water . $d_{mix}$ = depth of mixed layer . $F$ = net atmospheric heat flux . $ Delta T_c$ = climatology temperature correction . The only free parameter in this eqaution is the mixed layer depth, which was chosen to be 50 meters for all points. This value is roughly the global mean vlaue for the mixed layer depth as was determinded from the observations by Levitus (1982). . Redness of the SST anomalies . The standard deviation of the SST anoamlies do not aloine describe the large-scale character of the SST varaiblity. An important feature of the SSt variability is the increase of the variance in the SST power spectra with period, which is the so called redness of the spectra. If the SST anomalies follow an AR(1)-process than the redness can be estimated by the lag-1 correlation. . $C( omega) = frac{ sigma^2}{(1- alpha)^2+ omega^2}$ . $ sigma$ = standard deviation . $ omega$ = frequency . $ alpha$ = lag-1 correlation based on monthly mean time series . The increase of $C( omega)$ is only a function of $ alpha$, hence the redness $Q_{red}$ can be defined as . $Q_{red}$ = $ frac{1}{(1- alpha)^2}$ . Conclusions . fully coupled models are signifcantly different in terms of large-scale features of the SST variability than slab ocean models | only slab ocean models can be regarded as an AR(1) process | The diference between the AR(1)-process and the SST spectra in the simulations with fully dynamical ocean models is characterized by a slower increase of the SST variance from the shorter time periods to the longer time periods, which leads to increased variance of the SST on the seasonal and the decadal timescale relative to the fitted AR(1)-process. AMO and AMOC. . Simple red noise null hypothesis . c1 = 1 c2 = 0.86 c3 = 0.01 f, ax = plt.subplots(3, figsize = (12,4)) ax = ax.ravel() for realisation in range(0,3): white_noise_sequence = np.random.normal(0, 1, 1000) red_noise_sequence1 = np.zeros((len(white_noise_sequence))) red_noise_sequence2 = np.zeros((len(white_noise_sequence))) red_noise_sequence3 = np.zeros((len(white_noise_sequence))) for i in range(1, len(white_noise_sequence)): red_noise_sequence1[i] = c1 * red_noise_sequence1[i-1] + white_noise_sequence[i] red_noise_sequence2[i] = c2 * red_noise_sequence2[i-1] + white_noise_sequence[i] red_noise_sequence3[i] = c3 * red_noise_sequence3[i-1] + white_noise_sequence[i] ax[0].plot(red_noise_sequence1) ax[1].plot(red_noise_sequence2) ax[2].plot(red_noise_sequence3) .",
            "url": "https://florianboergel.github.io/personal_blog/jupyter/2020/11/05/red_noise_binder.html",
            "relUrl": "/jupyter/2020/11/05/red_noise_binder.html",
            "date": " • Nov 5, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Main site florianboergel.github.io [^1]. . On this side, you can find some code and lecture examples. .",
          "url": "https://florianboergel.github.io/personal_blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://florianboergel.github.io/personal_blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}